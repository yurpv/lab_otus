# Iptables
Для лабораторных работ использую Dell amd64, система виртуализации Virtualbox, при выполнении лабораторной работы использовал скаченый образ vagrantbox generic/ubuntu2204.

# Сценарии iptables

### Цель:
### Написать сценарии iptables.

### Описание/Пошаговая инструкция выполнения домашнего задания:</br>
- Что нужно сделать?

1. Реализовать knocking port
2. CentralRouter может попасть на ssh inetrRouter через knock скрипт пример в материалах.
> По настройке knock, воспльзовался данной сатьей https://interface31.ru/tech_it/2021/02/nastraivaem-port-knocking-v-linux-debian-ubuntu.html
4. Добавить inetRouter2, который виден(маршрутизируется (host-only тип сети для виртуалки)) с хоста или форвардится порт через локалхост.
5. Запустить nginx на centralServer.
6. Пробросить 80й порт на inetRouter2 8080.
7. Дефолт в инет оставить через inetRouter

# Выполнения домашнего задания
Для выполения лабораторной работы за основу взял Vagrantfile из домашнего задания Network, удалил office1Router, office1Router, office1Server, office2Server и добавил inetRouter2.
- Запускаем нашу лабораторную командой vagrant up
- Подготовим сервер и настроем knock:
```
root@inetRouter:~# cat /etc/iptables/rules.v4 
# Generated by iptables-save v1.8.7 on Thu Jul  4 04:37:16 2024
*filter
:INPUT DROP [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:TRAFFIC - [0:0]
:SSH-INPUT - [0:0]
:SSH-INPUTTWO - [0:0]
COMMIT
# Completed on Thu Jul  4 04:37:16 2024
# Generated by iptables-save v1.8.7 on Thu Jul  4 04:37:16 2024
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING ! -d 192.168.0.0/16 -o eth0 -j MASQUERADE
COMMIT
# Completed on Thu Jul  4 04:37:16 2024
# TRAFFIC chain for Port Knocking.
-A INPUT -j TRAFFIC
-A SSH-INPUT -m recent --set --name SSH1 --mask 255.255.255.255 --rsource -j DROP
-A SSH-INPUTTWO -m recent --set --name SSH2 --mask 255.255.255.255 --rsource -j DROP
-A TRAFFIC -p icmp -m icmp --icmp-type any -j ACCEPT
-A TRAFFIC -m state --state RELATED,ESTABLISHED -j ACCEPT
-A TRAFFIC -p tcp -m state --state NEW -m tcp --dport 22 -m recent --rcheck --seconds 30 --name SSH2 --mask 255.255.255.255 --rsource -j ACCEPT
-A TRAFFIC -p tcp -m state --state NEW -m tcp -m recent --remove --name SSH2 --mask 255.255.255.255 --rsource -j DROP
-A TRAFFIC -p tcp -m state --state NEW -m tcp --dport 4444 -m recent --rcheck --name SSH1 --mask 255.255.255.255 --rsource -j SSH-INPUTTWO
-A TRAFFIC -p tcp -m state --state NEW -m tcp -m recent --remove --name SSH1 --mask 255.255.255.255 --rsource -j DROP
-A TRAFFIC -p tcp -m state --state NEW -m tcp --dport 3333 -m recent --rcheck --name SSH0 --mask 255.255.255.255 --rsource -j SSH-INPUT
-A TRAFFIC -p tcp -m state --state NEW -m tcp -m recent --remove --name SSH0 --mask 255.255.255.255 --rsource -j DROP
-A TRAFFIC -p tcp -m state --state NEW -m tcp --dport 2222 -m recent --set --name SSH0 --mask 255.255.255.255 --rsource -j DROP
-A TRAFFIC -j DROP
COMMIT
```

- Откроем файл /etc/default/knockd и установим следующую опцию:
```
vi /etc/default/knockd
# control if we start knockd at init or not
# 1 = start
# anything else = don't start
# PLEASE EDIT /etc/knockd.conf BEFORE ENABLING
START_KNOCKD=1

# command line options
#KNOCKD_OPTS="-i eth1"
```

- Затем создадим файл юнита systemd:
```
root@inetRouter:~# vi /etc/systemd/system/knockd.service
cat: 'root@inetRouter:~#': No such file or directory
cat: vi: No such file or directory
[Unit]
Description=Port-Knock Daemon
After=network.target
Requires=network.target
Documentation=man:knockd(1)

[Service]
EnvironmentFile=-/etc/default/knockd
ExecStartPre=/usr/bin/sleep 1
ExecStart=/usr/sbin/knockd $KNOCKD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
Restart=always
SuccessExitStatus=0 2 15
ProtectSystem=full
CapabilityBoundingSet=CAP_NET_RAW CAP_NET_ADMIN

[Install]
WantedBy=multi-user.target
```

- Откроем файл /etc/knockd.conf и удалим оттуда все, кроме первой секции options, которую приведем к следующему виду:
```
root@inetRouter:~# vi /etc/knockd.conf
[options]
        UseSyslog
        Interface = eth1

[opencloseSSH]
        sequence      = 2222:tcp,3333:tcp,4444:tcp
        seq_timeout   = 15
        tcpflags      = syn
        start_command = /sbin/iptables -I INPUT 1 -s %IP% -p tcp --dport 22 -j ACCEPT
        cmd_timeout   = 30
        stop_command  = /sbin/iptables -D INPUT -s %IP% -p tcp --dport ssh -j ACCEPT
```

- Сохраним конфигурацию и запустим сервис:
```
systemctl start knockd
```

- Теперь с сервера centralServer постучимся inetRouter
```
root@centralServer:~# ssh vagrant@192.168.255.1
ssh: connect to host 192.168.255.1 port 22: Connection refused
```

- Как видим - все закрыто, подключиться к серверу невозможно. А теперь стучим:
```
root@centralServer:~# knock 192.168.255.1 2222 3333 4444
```

- Затем, в течение 30 секунд можно будет покдлючиться по ssh с centralRouter на inetRouter
```
root@centralServer:~# ssh vagrant@192.168.255.1
vagrant@192.168.255.1's password: 
Last login: Thu Jul  4 04:53:32 2024 from 192.168.0.2
vagrant@inetRouter:~$ 
```

При выполнении пунктов 2-5 выполняется установка nginx на centralServer, с помощью правил, указанных в файле iptables_inetrouter2.rules, на inetRouter2 добавляются правила, пробрасывающие порт 80 на inetRouter2 8080

Дефолт в инет оставлен через inetRouter.

Добавить inetRouter2, который виден(маршрутизируется (host-only тип сети для виртуалки)) с хоста или форвардится порт через локалхост
Добавлен в вагрант директивой box.vm.network "forwarded_port", guest: 8080, host: 1234, host_ip: "127.0.0.1", id: "nginx" (смотрите ansible-playbook файл)

запустить nginx на centralServer
Добавлено директивами: sudo apt install -y nginx; sudo systemctl enable nginx; sudo systemctl start nginx (смотрите ansible-playbook файл)

Пробросить 80й порт на inetRouter2 8080
В данном случае когда мы переходим по адресу 127.0.0.1 порт 1234 то мы попадаем на порт 8080 гостевой машины inetRouter2. Затем правилами iptables мы управляем пакетами, которые пришли на порт 8080 интерфейса eth0 и отправляем их по адресу 192.168.0.2 порт 80. Исходя из правил маршрутизации компьютер знает куда отправлять дальше данные пакеты, и он их отправляет на 192.168.255.3 (centralRouter), далее они попадают на веб-сервер 192.168.0.2 на порт 80 после чего возвращаются отправителю обратно в той же последовательности. (смотрите схему)

Правила iptables для inetRouter2:

sudo iptables -t nat -A PREROUTING -i eth0 -p tcp -m tcp --dport 8080 -j DNAT --to-destination 192.168.0.2:80
sudo iptables -t nat -A POSTROUTING --destination 192.168.0.2/32 -j SNAT --to-source 192.168.255.2
Стоит учесть при работе с iptables, что маскарадинг работает медленнее чем SNAT (обратитесь к документации).

Дополнительная информация:

Все гостевые машины по умолчанию ходят в интернет через 192.168.255.1 (inetRouter), для этого сделаны настройки (на примере centralServer):
```
cat /etc/netplan/00-installer-config.yaml
# This is the network config written by 'subiquity'
network:
  ethernets:
    enp0s3:
      dhcp4: true
      dhcp4-overrides:
          use-routes: false
      dhcp6: false
  version: 2
root@inetRouter:~# cat /etc/netplan/50-vagrant.yaml 
---
network:
  version: 2
  renderer: networkd
  ethernets:
    eth1:
      addresses:
      - 192.168.255.1/30
      routes:
      - to: default
        via: 192.168.255.1
      - to: 192.168.0.0/16
        via: 192.168.255.2
    eth2:
      addresses:
      - 192.168.50.10/24
```
Т.е. мы выключаем маршрут по умолчанию для интерфейса eth1 и прописываем шлюз по умолчанию для другого интерфейса, который смотрит в centralRouter. (более подробная информация содержится в ansible-playbook файле)
